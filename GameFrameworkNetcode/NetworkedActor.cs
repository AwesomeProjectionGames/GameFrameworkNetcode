#nullable enable

using System;
using AwesomeProjectionCoreUtils.Extensions;
using GameFramework;
using Unity.Collections;
using Unity.Netcode;
using UnityEngine;

namespace UnityGameFrameworkImplementations.Core.Netcode
{
    /// <summary>
    /// The netcode implementation of an actor.
    /// Keeps the UUID and owner in sync across the network.
    /// </summary>
    public class NetworkedActor : AbstractActor
    {
        public override string UUID => networkedUUID.Value.ToString();

        public NetworkVariable<FixedString64Bytes> networkedUUID = new NetworkVariable<FixedString64Bytes>(writePerm: NetworkVariableWritePermission.Server, readPerm: NetworkVariableReadPermission.Everyone);
        public NetworkVariable<NetworkObjectReference> ownerReference = new NetworkVariable<NetworkObjectReference>(writePerm: NetworkVariableWritePermission.Server, readPerm: NetworkVariableReadPermission.Everyone);

        public override void OnNetworkSpawn()
        {

            ownerReference.OnValueChanged += HandleOwnerChanged;

            // This is usefull only if it's an other client joining the game mid-session (and the ownerReference is already set but didn't trigger the event)
            if (!ownerReference.Value.Equals(default))
            {
                HandleOwnerChanged(default, ownerReference.Value);
            }
            if (IsServer && networkedUUID.Value.IsEmpty)
            {
                TryToChangeUUID(GetUniqueUuid());
            }
        }

        /// <summary>
        /// Generates a unique UUID for this actor. By default, it uses Guid.NewGuid(), but you can override this method to implement your own UUID generation logic if needed.
        /// Use when spawning actors on the server to ensure they have a unique identifier across the network.
        /// You should override this for player actors to be consistent with the player UUIDs generated by your PlayerIdentityManager, if you have one.
        /// </summary>
        /// <returns>A unique UUID string.</returns>
        protected virtual string GetUniqueUuid()
        {
            return Guid.NewGuid().ToString();
        }

        public override void OnNetworkDespawn()
        {
            base.OnNetworkDespawn();
            ownerReference.OnValueChanged -= HandleOwnerChanged;
            if (_owner != null)
            {
                _owner.OnAnyOwnerChanged -= HandleAnyOwnerChange;
            }
        }

        public override bool TryToChangeUUID(string newUUID)
        {
            if (!IsServer) return false;
            if (string.IsNullOrEmpty(newUUID))
            {
                Debug.LogError("Cannot set an empty or null UUID.");
                return false;
            }
            networkedUUID.Value = newUUID;
            return true;
        }

        // -------------------------------------------------------------------------
        // Public API
        // -------------------------------------------------------------------------

        public override void SetOwner(IActor newOwner)
        {
            if (!newOwner.IsAlive())
            {
                Debug.LogError("Cannot set owner to null.");
                return;
            }
            if (newOwner is not NetBehaviour newOwnerNetBehaviour)
            {
                Debug.LogError("New owner must be a NetworkBehaviour.");
                return;
            }

            if (!IsServer && !newOwner.IsOwned())
            {
                Debug.LogError("Can only set owner to an already owned actor when not the server.");
                return;
            }

            SetOwnerServerRpc(newOwnerNetBehaviour.NetworkObject);
        }

        public override void RemoveOwner()
        {
            if (!Owner.IsAlive())
            {
                Debug.LogError("No owner to remove.");
                return;
            }
            if (!IsServer && !Owner!.IsOwned())
            {
                Debug.LogError("Can only remove owner if it's already owned by the same player when not the server.");
                return;
            }
            RemoveOwnerServerRpc();
        }

        // -------------------------------------------------------------------------
        // Server Logic.
        // -------------------------------------------------------------------------

        [Rpc(SendTo.Server, InvokePermission = RpcInvokePermission.Everyone)]
        public void SetOwnerServerRpc(NetworkObjectReference newOwnerRef, ServerRpcParams serverRpcParams = default)
        {
            if (!IsServer) return;

            ulong senderId = serverRpcParams.Receive.SenderClientId;

            // Verify authority over this actor
            if (senderId != OwnerClientId && senderId != NetworkManager.ServerClientId)
            {
                Debug.LogError($"[Security] Client {senderId} tried to modify actor {name} but does not own it.");
                return;
            }

            // Optional: Verify authority over the new owner (parent) to prevent spamming/griefing
            // For now, we only enforcing ownership of the child, assuming that parenting to a public object might be valid in some game logic,
            // or that the parent's own security checks (if any) would handle it. 
            // Strengthening this to require ownership of BOTH would be safer but more restrictive.
            // Given the audit scope, securing 'this' is the critical first step.

            ownerReference.Value = newOwnerRef;
        }

        [Rpc(SendTo.Server, InvokePermission = RpcInvokePermission.Everyone)]
        public void RemoveOwnerServerRpc(ServerRpcParams serverRpcParams = default)
        {
            if (!IsServer) return;

            ulong senderId = serverRpcParams.Receive.SenderClientId;
            if (senderId != OwnerClientId && senderId != NetworkManager.ServerClientId)
            {
                Debug.LogError($"[Security] Client {senderId} tried to remove owner of {name} but does not own it.");
                return;
            }

            ownerReference.Value = new NetworkObjectReference(); // Clear the owner reference (equivalent to null)
        }

        private void UpdateNetworkBehaviorOwnsership()
        {
            if (!IsServer) return;
            IMachine? machine = (this as IActor).Controller?.Machine;
            if (machine.IsAlive())
            {
                NetworkObject.ChangeOwnership(machine!.ClientId);
            }
            else
            {
                NetworkObject.RemoveOwnership();
            }
        }


        // -------------------------------------------------------------------------
        // Reactive Logic (Runs on All Clients + Server)
        // -------------------------------------------------------------------------

        /// <summary>
        /// This is the SINGLE point of truth. All logic reacts to the NetworkVariable change.
        /// </summary>
        private void HandleOwnerChanged(NetworkObjectReference previousValue, NetworkObjectReference newValue)
        {
            IActor? lastOwner = _owner;
            if (newValue.TryGet(out var newOwnerObj))
            {
                _owner = newOwnerObj.GetComponent<IActor>();
            }
            else
            {
                _owner = null;
            }

            OnOwnerDidChange(lastOwner, _owner);
            if (IsServer)
            {
                UpdateNetworkBehaviorOwnsership();
            }
        }
    }
}