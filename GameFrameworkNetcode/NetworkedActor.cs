#nullable enable

using System;
using AwesomeProjectionCoreUtils.Extensions;
using GameFramework;
using Unity.Collections;
using Unity.Netcode;
using UnityEngine;

namespace UnityGameFrameworkImplementations.Core.Netcode
{
    /// <summary>
    /// The netcode implementation of an actor.
    /// Keeps the UUID and owner in sync across the network.
    /// </summary>
    public class NetworkedActor : AbstractActor
    {
        public override string UUID => networkedUUID.Value.ToString();

        public NetworkVariable<FixedString64Bytes> networkedUUID = new NetworkVariable<FixedString64Bytes>(writePerm: NetworkVariableWritePermission.Server, readPerm: NetworkVariableReadPermission.Everyone);
        public NetworkVariable<NetworkObjectReference> ownerReference = new NetworkVariable<NetworkObjectReference>(writePerm: NetworkVariableWritePermission.Server, readPerm: NetworkVariableReadPermission.Everyone);
        
        public override void OnNetworkSpawn()
        {
            
            ownerReference.OnValueChanged += HandleOwnerChanged;
            
            // This is usefull only if it's an other client joining the game mid-session (and the ownerReference is already set but didn't trigger the event)
            if (!ownerReference.Value.Equals(default))
            {
                HandleOwnerChanged(default, ownerReference.Value);
            }
            if (IsServer && networkedUUID.Value.IsEmpty)
            {
                TryToChangeUUID(GetUniqueUuid());
            }
        }
        
        /// <summary>
        /// Generates a unique UUID for this actor. By default, it uses Guid.NewGuid(), but you can override this method to implement your own UUID generation logic if needed.
        /// Use when spawning actors on the server to ensure they have a unique identifier across the network.
        /// You should override this for player actors to be consistent with the player UUIDs generated by your PlayerIdentityManager, if you have one.
        /// </summary>
        /// <returns>A unique UUID string.</returns>
        protected virtual string GetUniqueUuid()
        {
            return Guid.NewGuid().ToString();
        }

        public override void OnNetworkDespawn()
        {
            base.OnNetworkDespawn();
            ownerReference.OnValueChanged -= HandleOwnerChanged;
            if (_owner != null)
            {
                _owner.OnAnyOwnerChanged -= HandleAnyOwnerChange;
            }
        }

        public override bool TryToChangeUUID(string newUUID)
        {
            if (!IsServer) return false;
            if (string.IsNullOrEmpty(newUUID))
            {
                Debug.LogError("Cannot set an empty or null UUID.");
                return false;
            }
            networkedUUID.Value = newUUID;
            return true;
        }

        // -------------------------------------------------------------------------
        // Public API
        // -------------------------------------------------------------------------
 
        public override void SetOwner(IActor newOwner)
        {
            if (!newOwner.IsAlive())
            {
                Debug.LogError("Cannot set owner to null.");
                return;
            }
            if (newOwner is not NetBehaviour newOwnerNetBehaviour)
            {
                Debug.LogError("New owner must be a NetworkBehaviour.");
                return;
            }

            if (!IsServer && !newOwner.IsOwned())
            {
                Debug.LogError("Can only set owner to an already owned actor when not the server.");
                return;
            }

            SetOwnerServerRpc(newOwnerNetBehaviour.NetworkObject);
        }
        
        public override void RemoveOwner()
        {
            if(!Owner.IsAlive())
            {
                Debug.LogError("No owner to remove.");
                return;
            }
            if (!IsServer && !Owner!.IsOwned())
            {
                Debug.LogError("Can only remove owner if it's already owned by the same player when not the server.");
                return;
            }
            RemoveOwnerServerRpc();
        }
        
        // -------------------------------------------------------------------------
        // Server Logic. Warning : currently, a non owner could hack the packet and possess an actor they shouldn't have access to.
        // -------------------------------------------------------------------------

        [Rpc(SendTo.Server, InvokePermission = RpcInvokePermission.Everyone)]
        public void SetOwnerServerRpc(NetworkObjectReference newOwnerRef)
        {
            if (!IsServer) return;
            ownerReference.Value = newOwnerRef;
        }
        
        [Rpc(SendTo.Server, InvokePermission = RpcInvokePermission.Everyone)]
        public void RemoveOwnerServerRpc()
        {
            if (!IsServer) return;
            ownerReference.Value = new NetworkObjectReference(); // Clear the owner reference (equivalent to null)
        }

        private void UpdateNetworkBehaviorOwnsership()
        {
            if (!IsServer) return;
            IMachine? machine = (this as IActor).Controller?.Machine;
            if (machine.IsAlive())
            {
                NetworkObject.ChangeOwnership(machine!.ClientId);
            }
            else
            {
                NetworkObject.RemoveOwnership();
            }
        }
        
        
        // -------------------------------------------------------------------------
        // Reactive Logic (Runs on All Clients + Server)
        // -------------------------------------------------------------------------
        
        /// <summary>
        /// This is the SINGLE point of truth. All logic reacts to the NetworkVariable change.
        /// </summary>
        private void HandleOwnerChanged(NetworkObjectReference previousValue, NetworkObjectReference newValue)
        {
            IActor? lastOwner = _owner;
            if (newValue.TryGet(out var newOwnerObj))
            {
                _owner = newOwnerObj.GetComponent<IActor>();
            }
            else
            {
                _owner = null;
            }

            OnOwnerDidChange(lastOwner, _owner);
            if (IsServer)
            {
                UpdateNetworkBehaviorOwnsership();
            }
        }
    }
}