#nullable enable

using System;
using AwesomeProjectionCoreUtils.Extensions;
using GameFramework;
using Unity.Collections;
using Unity.Netcode;
using UnityEngine;

namespace UnityGameFrameworkImplementations.Core.Netcode
{
    /// <summary>
    /// The netcode implementation of an actor.
    /// Keeps the UUID and owner in sync across the network.
    /// </summary>
    public class NetworkedActor : AbstractActor
    {
        public override string UUID => networkedUUID.Value.ToString();

        public NetworkVariable<FixedString64Bytes> networkedUUID = new NetworkVariable<FixedString64Bytes>(writePerm: NetworkVariableWritePermission.Server, readPerm: NetworkVariableReadPermission.Everyone);
        public NetworkVariable<NetworkObjectReference> ownerReference = new NetworkVariable<NetworkObjectReference>(writePerm: NetworkVariableWritePermission.Server, readPerm: NetworkVariableReadPermission.Everyone);
        
        public override void OnNetworkSpawn()
        {
            if(!IsServer)
            {
                ownerReference.OnValueChanged += HandleOwnerChanged;
            }
            // This is usefull only if it's an other client joining the game mid-session (and the ownerReference is already set but didn't trigger the event)
            if (!ownerReference.Value.Equals(default))
            {
                HandleOwnerChanged(default, ownerReference.Value);
            }
            if (IsServer && networkedUUID.Value.IsEmpty)
            {
                TryToChangeUUID(GetUniqueUuid());
            }
        }
        
        /// <summary>
        /// Generates a unique UUID for this actor. By default, it uses Guid.NewGuid(), but you can override this method to implement your own UUID generation logic if needed.
        /// Use when spawning actors on the server to ensure they have a unique identifier across the network.
        /// You should override this for player actors to be consistent with the player UUIDs generated by your PlayerIdentityManager, if you have one.
        /// </summary>
        /// <returns>A unique UUID string.</returns>
        protected virtual string GetUniqueUuid()
        {
            return Guid.NewGuid().ToString();
        }

        public override void OnNetworkDespawn()
        {
            base.OnNetworkDespawn();
            if(!IsServer)
            {
                ownerReference.OnValueChanged -= HandleOwnerChanged;
            }
            if (_owner != null)
            {
                _owner.OnAnyOwnerChanged -= HandleAnyOwnerChange;
            }
        }

        public override bool TryToChangeUUID(string newUUID)
        {
            if (!IsServer) return false;
            if (string.IsNullOrEmpty(newUUID))
            {
                Debug.LogError("Cannot set an empty or null UUID.");
                return false;
            }
            networkedUUID.Value = newUUID;
            return true;
        }

        public override void SetOwner(IActor newOwner)
        {
            if (!newOwner.IsAlive())
            {
                Debug.LogError("Cannot set owner to null.");
                return;
            }
            if (newOwner is not NetBehaviour newOwnerNetBehaviour)
            {
                Debug.LogError("New owner must be a NetworkBehaviour.");
                return;
            }

            SetOwnerServerRpc(newOwnerNetBehaviour.NetworkObject);
        }
        
        [Rpc(SendTo.Server)]
        public void SetOwnerServerRpc(NetworkObjectReference newOwnerRef)
        {
            if (!IsServer) return;

            var newOwner = newOwnerRef.TryGet(out var ownerObj) ? ownerObj.GetComponent<IActor>() : null;
            if (newOwner == null)
            {
                Debug.LogError("Failed to set owner: Invalid NetworkObjectReference.");
                return;
            }
            
            IActor? lastOwner = _owner;
            _owner = newOwner;
            ownerReference.Value = newOwnerRef;
            OnOwnerDidChange(lastOwner, _owner);
        }
        
        private void HandleOwnerChanged(NetworkObjectReference previousValue, NetworkObjectReference newValue)
        {
            IActor? lastOwner = _owner;
            if (newValue.TryGet(out var newOwnerObj))
            {
                _owner = newOwnerObj.GetComponent<IActor>();
            }
            else
            {
                _owner = null;
            }

            OnOwnerDidChange(lastOwner, _owner);
        }

        public override void RemoveOwner()
        {
            if (!IsOwner)
            {
                Debug.LogError("Only the owner can remove itself as the owner.");
                return;
            }
            RemoveOwnerServerRpc();
        }
        
        [Rpc(SendTo.Server)]
        public void RemoveOwnerServerRpc()
        {
            if (!IsServer) return;

            IActor? lastOwner = _owner;
            _owner = null;
            ownerReference.Value = new NetworkObjectReference(); // Clear the owner reference (equivalent to null)
            OnOwnerDidChange(lastOwner, null);
        }
        
        protected override void HandleAnyOwnerChange()
        {
            ServerChangeOwnerShip();
            if (IsServer)
            {
                ProcessSafeOwnershipChange();
            }
        }

        private void ServerChangeOwnerShip()
        {
            if (!IsServer) return;
            IMachine? machine = (this as IActor).Controller?.Machine;
            if (machine.IsAlive())
            {
                NetworkObject.ChangeOwnership(machine!.ClientId);
            }
            else
            {
                NetworkObject.RemoveOwnership();
            }
        }
        
        public override void OnGainedOwnership()
        {
            ProcessSafeOwnershipChange();
        }

        public override void OnLostOwnership()
        {
            ProcessSafeOwnershipChange();
        }
    }
}